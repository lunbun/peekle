from typing import cast
import sys
import ast
import functools
from .. import il
from ..transform import analysis

class CodeGenerator:
    STOP = ast.parse('''
def stop(result):
    'auto-generated by peekle'
    print(result)
''', mode='exec').body[0]

    FIND_CLASS = ast.parse('''
def findClass(module: str, name: str):
    'auto-generated by peekle'
    obj = sys.modules[module]
    for attr in name.split('.'):
        obj = getattr(obj, attr)
    return obj
''', mode='exec').body[0]
    
    BUILD = ast.parse('''
def build(obj, args: dict):
    'auto-generated by peekle'
    setstate = getattr(obj, '__setstate__', None)
    if setstate is not None:
        setstate(args)
    else:
        obj.__dict__.update(args)
''', mode='exec').body[0]

    dispatch = {}

    def __init__(self):
        self.program: il.Program = None
        self.statements: list[ast.stmt] = []

        # Map of IL nodes to AST nodes that can be reordered and inlined
        self.temporaryMap: dict[il.VariableInsn, ast.AST] = {}
        self.validVariables: set[il.VariableInsn] = set()

        self.imports: set[str] = set()
        self.needsStop = False
        self.needsFindClass = False
        self.needsBuild = False

    def _generateConstantGlobalValue(self, value: il.ConstantGlobal) -> ast.expr:
        needsModule = True
        nameComponents = None
        
        if value.name is not None:
            nameComponents = value.name.split('.')

            # Check if the global is a builtin function, in which case we can
            # simplify the expression
            if value.module in sys.modules:
                global_ = sys.modules[value.module]
                i = 0
                while i < len(nameComponents):
                    if not hasattr(global_, nameComponents[i]):
                        break

                    global_ = getattr(global_, nameComponents[i])
                    if global_ in analysis.BUILTIN_CALLS:
                        needsModule = False
                        nameComponents = nameComponents[i:]
                    i += 1
        
        if needsModule:
            components = value.module.split('.')
            if nameComponents is not None:
                components += nameComponents

            self.imports.add(components[0])
        else:
            components = [] if nameComponents is None else nameComponents

        v = ast.Name(id=components[0], ctx=ast.Load())
        for component in components[1:]:
            v = ast.Attribute(value=v, attr=component, ctx=ast.Load())
        return v

    def _generateValue(self, value: il.Value) -> ast.expr:
        if isinstance(value, il.ConstantValue):
            return ast.Constant(value=value.value)
        elif isinstance(value, il.ConstantTuple):
            return ast.Tuple(elts=[self._generateValue(v) for v in value.values], ctx=ast.Load())
        elif isinstance(value, il.ConstantList):
            return ast.List(elts=[self._generateValue(v) for v in value.values], ctx=ast.Load())
        elif isinstance(value, il.ConstantDict):
            keys = [self._generateValue(k[0]) for k in value.values]
            values = [self._generateValue(k[1]) for k in value.values]
            return ast.Dict(keys=keys, values=values)
        elif isinstance(value, il.ConstantSet):
            return ast.Call(func=ast.Name(id='set', ctx=ast.Load()), args=[self._generateValue(v) for v in value.values], keywords=[])
        elif isinstance(value, il.ConstantFrozenSet):
            return ast.Call(func=ast.Name(id='frozenset', ctx=ast.Load()), args=[self._generateValue(v) for v in value.values], keywords=[])
        elif isinstance(value, il.ConstantGlobal):
            return self._generateConstantGlobalValue(value)
        elif isinstance(value, il.VariableInsn):
            if value in self.temporaryMap:
                # Each temporary variable should only be used once to avoid code 
                # duplication
                return self.temporaryMap.pop(value)
            else:
                if not value in self.validVariables:
                    raise ValueError(f'Variable {value} is not valid')
                return ast.Name(id=value.name, ctx=ast.Load())
        else:
            raise NotImplementedError(f'Unsupported value type: {value}')
            
    def _generateStopExpr(self, insn: il.Insn):
        self.needsStop = True
        args = [self._generateValue(v) for v in insn.args]
        return ast.Call(func=ast.Name(id='stop', ctx=ast.Load()), args=args, keywords=[])
    dispatch[il.InsnType.STOP] = _generateStopExpr
            
    def _generateCallExpr(self, insn: il.Insn):
        callee = self._generateValue(insn.args[0])
        args = insn.args[1]
        if isinstance(args, il.ConstantTuple):
            args = [self._generateValue(v) for v in args.values]
        else:
            args = [ast.Starred(value=self._generateValue(args), ctx=ast.Load())]
        return ast.Call(func=callee, args=args, keywords=[])
    dispatch[il.InsnType.CALL] = _generateCallExpr

    def _generateGlobalExpr(self, insn: il.Insn):
        self.needsFindClass = True
        args = [self._generateValue(v) for v in insn.args]
        return ast.Call(func=ast.Name(id='findClass', ctx=ast.Load()), args=args, keywords=[])
    dispatch[il.InsnType.GLOBAL] = _generateGlobalExpr

    def _generateGetAttrExpr(self, insn: il.Insn):
        obj = self._generateValue(insn.args[0])
        attr = insn.args[1]
        if isinstance(attr, il.ConstantValue) and isinstance(attr.value, str):
            return ast.Attribute(value=obj, attr=attr.value, ctx=ast.Load())
        else:
            return ast.Call(func=ast.Name(id='getattr', ctx=ast.Load()), args=[obj, self._generateValue(attr)], keywords=[])
    dispatch[il.InsnType.GET_ATTR] = _generateGetAttrExpr

    def _generateSetAttrExpr(self, insn: il.Insn):
        obj = self._generateValue(insn.args[0])
        attr = insn.args[1]
        value = self._generateValue(insn.args[2])
        if isinstance(attr, il.ConstantValue) and isinstance(attr.value, str):
            return ast.Assign(targets=[ast.Attribute(value=obj, attr=attr.value, ctx=ast.Store())], value=value, lineno=0)
        else:
            return ast.Call(func=ast.Name(id='setattr', ctx=ast.Load()), args=[obj, self._generateValue(attr), value], keywords=[])
    dispatch[il.InsnType.SET_ATTR] = _generateSetAttrExpr

    def _generateGetItemExpr(self, insn: il.Insn):
        obj = self._generateValue(insn.args[0])
        key = self._generateValue(insn.args[1])
        return ast.Subscript(value=obj, slice=ast.Index(value=key), ctx=ast.Load())
    dispatch[il.InsnType.GET_ITEM] = _generateGetItemExpr
    
    def _generateSetItemExpr(self, insn: il.Insn):
        obj = self._generateValue(insn.args[0])
        key = self._generateValue(insn.args[1])
        value = self._generateValue(insn.args[2])
        return ast.Assign(targets=[ast.Subscript(value=obj, slice=ast.Index(value=key), ctx=ast.Store())], value=value, lineno=0)
    dispatch[il.InsnType.SET_ITEM] = _generateSetItemExpr
    
    def _generateLocalExpr(self, insn: il.Insn):
        name = insn.args[0]
        if isinstance(name, il.ConstantValue) and isinstance(name.value, str):
            return ast.Name(id=name.value, ctx=ast.Load())
        else:
            l = ast.Call(func=ast.Name(id='locals', ctx=ast.Load()), args=[], keywords=[])
            return ast.Subscript(value=l, slice=ast.Index(value=self._generateValue(name)), ctx=ast.Load())
    dispatch[il.InsnType.LOCAL] = _generateLocalExpr

    def _generateMutableConstantExpr(self, insn: il.Insn):
        return self._generateValue(insn.args[0])
    dispatch[il.InsnType.MUTABLE_CONSTANT] = _generateMutableConstantExpr

    def _generateBuildExpr(self, insn: il.Insn):
        self.needsBuild = True
        args = [self._generateValue(v) for v in insn.args]
        return ast.Call(func=ast.Name(id='build', ctx=ast.Load()), args=args, keywords=[])
    dispatch[il.InsnType.BUILD] = _generateBuildExpr

    def _generateLenExpr(self, insn: il.Insn):
        args = [self._generateValue(v) for v in insn.args]
        return ast.Call(func=ast.Name(id='len', ctx=ast.Load()), args=args, keywords=[])
    dispatch[il.InsnType.LEN] = _generateLenExpr

    def _generateExtendExpr(self, insn: il.Insn):
        obj = self._generateValue(insn.args[0])
        values = self._generateValue(insn.args[1])
        return ast.Call(func=ast.Attribute(value=obj, attr='extend', ctx=ast.Load()), args=[values], keywords=[])
    dispatch[il.InsnType.EXTEND] = _generateExtendExpr

    def _generateCompareExpr(self, insn: il.Insn, op: ast.cmpop):
        left = self._generateValue(insn.args[0])
        right = self._generateValue(insn.args[1])
        return ast.Compare(left=left, ops=[op], comparators=[right])
    dispatch[il.InsnType.EQUALS] = functools.partial(_generateCompareExpr, op=ast.Eq())
    dispatch[il.InsnType.NOT_EQUALS] = functools.partial(_generateCompareExpr, op=ast.NotEq())
    dispatch[il.InsnType.LESS_THAN] = functools.partial(_generateCompareExpr, op=ast.Lt())
    dispatch[il.InsnType.LESS_EQUALS] = functools.partial(_generateCompareExpr, op=ast.LtE())
    dispatch[il.InsnType.GREATER_THAN] = functools.partial(_generateCompareExpr, op=ast.Gt())
    dispatch[il.InsnType.GREATER_EQUALS] = functools.partial(_generateCompareExpr, op=ast.GtE())

    def _generateBinExpr(self, insn: il.Insn, op: ast.operator):
        left = self._generateValue(insn.args[0])
        right = self._generateValue(insn.args[1])
        return ast.BinOp(left=left, op=op, right=right)
    dispatch[il.InsnType.ADD] = functools.partial(_generateBinExpr, op=ast.Add())
    dispatch[il.InsnType.SUB] = functools.partial(_generateBinExpr, op=ast.Sub())
    dispatch[il.InsnType.MUL] = functools.partial(_generateBinExpr, op=ast.Mult())
    dispatch[il.InsnType.FLOOR_DIV] = functools.partial(_generateBinExpr, op=ast.FloorDiv())
    dispatch[il.InsnType.TRUE_DIV] = functools.partial(_generateBinExpr, op=ast.Div())
    dispatch[il.InsnType.MOD] = functools.partial(_generateBinExpr, op=ast.Mod())
    dispatch[il.InsnType.POW] = functools.partial(_generateBinExpr, op=ast.Pow())
    dispatch[il.InsnType.BITWISE_AND] = functools.partial(_generateBinExpr, op=ast.BitAnd())
    dispatch[il.InsnType.BITWISE_OR] = functools.partial(_generateBinExpr, op=ast.BitOr())
    dispatch[il.InsnType.BITWISE_XOR] = functools.partial(_generateBinExpr, op=ast.BitXor())
    dispatch[il.InsnType.LSHIFT] = functools.partial(_generateBinExpr, op=ast.LShift())
    dispatch[il.InsnType.RSHIFT] = functools.partial(_generateBinExpr, op=ast.RShift())

    def _generatePoisonExpr(self, insn: il.Insn):
        self.imports.add('pickle')
        error = ast.Attribute(value=ast.Name(id='pickle', ctx=ast.Load()), attr='UnpicklingError', ctx=ast.Load())
        error = ast.Call(func=error, args=[self._generateValue(insn.args[0])], keywords=[])
        return ast.Raise(exc=error, cause=None, lineno=0)
    dispatch[il.InsnType.POISON] = _generatePoisonExpr

    def _generateSetVar(self, insn: il.VariableInsn, expr: ast.expr):
        self.validVariables.add(insn)
        stmt = ast.Assign(targets=[ast.Name(id=insn.name, ctx=ast.Store())], value=expr, lineno=0)
        return stmt
            
    def _emitInsn(self, insn: il.Insn):
        hasUses = insn.hasUses()
        hasSideEffects = analysis.hasSideEffects(insn)
        if not hasUses and not hasSideEffects:
            return
        
        expr = self.dispatch[insn.op](self, insn)
        stmt: ast.stmt = None
        if isinstance(expr, ast.stmt):
            stmt = expr
        elif hasUses:
            insn = cast(il.VariableInsn, insn)
            if len(insn.uses) == 1:
                self.temporaryMap[insn] = expr
            else:
                stmt = self._generateSetVar(insn, expr)
        else:
            stmt = ast.Expr(value=expr, lineno=0)

        if hasSideEffects:
            # If the instruction has side effects, we need to emit all temporary
            # variables as they can no longer be reordered. This has to be done
            # after the instruction is emitted in case the instruction uses any
            # of the temporaries.
            setVars = [self._generateSetVar(var, expr) for var, expr in self.temporaryMap.items()]
            self.statements.extend(setVars)
            self.temporaryMap.clear()

        if stmt is not None:
            self.statements.append(stmt)

    # Generate a Python AST for the given IL program
    def generate(self, program: il.Program) -> ast.Module:
        if self.program is not None:
            raise ValueError('Code generator already has a program')

        self.program = program
        for insn in program:
            self._emitInsn(insn)

        prefixStmts = []
        if self.needsFindClass:
            self.imports.add('sys')

        for m in self.imports:
            prefixStmts.append(ast.Import(names=[ast.alias(name=m, asname=None)]))

        if self.needsStop:
            prefixStmts.append(self.STOP)
        if self.needsFindClass:
            prefixStmts.append(self.FIND_CLASS)
        if self.needsBuild:
            prefixStmts.append(self.BUILD)

        self.statements = prefixStmts + self.statements

        module = ast.Module(body=self.statements, type_ignores=[])

        self.program = None
        self.statements = []
        self.ilMap = {}

        return module
    
    # Generate Python source code for the given IL program
    def generateSource(self, program: il.Program) -> str:
        return ast.unparse(self.generate(program))
